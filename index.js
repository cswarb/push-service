var express = require("express");
const fs = require('fs');
const path = require('path');
const https = require('http');
const webpush = require('web-push');
const dotenv = require('dotenv').config();

var app = express();
const options = {
    key: fs.readFileSync(path.join(__dirname, './key.pem')),
    cert: fs.readFileSync(path.join(__dirname, './cert.pem')),
}

// VAPID keys should be generated only once
app.get('/generate-vapid-keys', (req, res) => {
    const keys = webpush.generateVAPIDKeys();
    console.log(keys)
    return res.send(keys);
    //Add these keys to .env, and add the public key to the client when registered a push subscription
})

app.get('/push', (req, res) => {
    const options = {
        vapidDetails: {
            subject: 'https://localhost:3005', //mailto or domain //This piece of information will actually be sent to the web push service as part of the request to trigger a push. The reason this is done is so that if a web push service needs to get in touch with the sender, they have some information that will enable them to.
            //keys generated by calling /generate-vapid-keys
            publicKey: process.env.PUBLIC_VAPID_KEY,
            privateKey: process.env.PRIVATE_VAPID_KEY
        },
        TTL: 60 * 60 //Time until notification is deleted if unable to be delivered
    };

    //Get this test subscription by loading the client, giving it the public key, 
    //and copying the pushSubscription object it returns after subscribing successfully...

    //This should ideally come from a DB? e.g. https://developers.google.com/web/fundamentals/push-notifications/subscribing-a-user
    const clientPushSubscription = {
        //Unsure about this push service endpoint being a third party (Firebase)? Do we need to create our own? https://developers.google.com/web/ilt/pwa/introduction-to-push-notifications
        //We need to setup our own FCM?
            //https://firebase.google.com/docs/cloud-messaging/
            //https://developers.google.com/web/updates/2016/07/web-push-interop-wins
        endpoint: "https://fcm.googleapis.com/fcm/send/fh0q-_D6xyU:APA91bFcWrb23tFq6f9LRstCxw-lxzmjLH1wwibMUOKArKBXuPfglmeqWsbr2HINqBAMrShNHhpmbqykx8CfP4471hP7G9yJ8cpR2pBe5fBac00UrfpByxD0IpZdJah9IlAq3FKp-Kwa",
        expirationTime: null,
        keys: {
            p256dh: "BHqC95vqXROU2-kWxED1keLYrZMSnJd74c7ShWr5CtiiitdUie0m5ZM7WAVqwsr_i1fM-KQv1umcZtGMasg1WYM",
            auth: "ycw0dDLYuE5eIRXqhTzL-Q"
        }
    };

    const payload = JSON.stringify({
        body: 'from server body',
        data: { primaryKey: 'from server custom data' }
    });

    //sendNotification() automatically encrypts the payload
    webpush.sendNotification(
        clientPushSubscription,
        payload,
        options
    ).then(() => {
        res.status(200).send({ success: true });
    }).catch((err) => {
        if (err.statusCode) {
            res.status(err.statusCode).send(err.body);
        } else {
            res.status(400).send(err.message);
        }
    });
});

var server = https.createServer(options, app);
server.listen(3005, () => console.log('Push service listening on 3005...'));






//Process
// - Generate vapid keys by hitting route, and enter in here, and application main.js
// - Initialise service worker on browser, and generate a pushSubscription object and copy into here into sendNotification method
// - Call /push on here to send a push notification to the browser. 
    //Each browser will generate its own subscription however, so multiple subscriptions may need to be...
    //...tied to the same user in the database



    //Links
    //https://developers.google.com/web/fundamentals/push-notifications/web-push-protocol
    //https://developers.google.com/web/fundamentals/push-notifications/subscribing-a-user








//Portal
//- Create service to have push notifications, and have it generate VAPID keys and store them in ENV
//
//- Have an area in settings to turn on/off push notifications
    //- When turning them ON, it passes the registration object to be stored against the DID and saves in DB (use the endpoint as a unique identifier in database?)
    //- When turning them OFF, it removes from the DB the registration object against the DID
    //There may be multiple registration obejct against a single DID to represent each browser?
//
//Then in the Push service client (backend), when an event happens:
    //- Call web-push sendNotification() with the VAPID keys, and each browsers registration info from the DB...
    //...(so same notification will be sent to multiple browsers)