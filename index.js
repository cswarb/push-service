var express = require('express');
const fs = require('fs');
const path = require('path');
const http = require('http');
const webpush = require('web-push');
const cors = require('cors')
const dotenv = require('dotenv').config();

var app = express();

app.use(cors());
app.use(express.json());

const options = {
    key: fs.readFileSync(path.join(__dirname, './key.pem')),
    cert: fs.readFileSync(path.join(__dirname, './cert.pem')),
}

let subscriptions = [];

// VAPID keys should be generated only once
app.get('/generate-vapid-keys', (req, res) => {
    const keys = webpush.generateVAPIDKeys();
    return res.send(keys);
    //Add these keys to .env, and add the public key to the client when registered a push subscription
})

app.get('/keys', (req, res) => {
    return res.json({ pub: process.env.PUBLIC_VAPID_KEY, pri: process.env.PRIVATE_VAPID_KEY });
})

app.post('/add-subscription', (req, res) => {
    subscriptions.push(req.body?.pushSubscription);
    return res.json(subscriptions);
})

app.get('/remove-subscription', (req, res) => {
    subscriptions = subscriptions.filter((val, i) => {
        return val.endpoint !== req.query.endpoint;
    });
    return res.json(subscriptions);
})

app.get('/subscriptions', (req, res) => {
    return res.json(subscriptions);
})

app.get('/push', (req, res) => {
    const options = {
        vapidDetails: {
            subject: 'https://localhost:3005', //mailto or domain //This piece of information will actually be sent to the web push service as part of the request to trigger a push. The reason this is done is so that if a web push service needs to get in touch with the sender, they have some information that will enable them to.
            //keys generated by calling /generate-vapid-keys
            publicKey: process.env.PUBLIC_VAPID_KEY,
            privateKey: process.env.PRIVATE_VAPID_KEY
        },
        TTL: 60 * 60 //Time until notification is deleted if unable to be delivered
    };


    //Get this test subscription by loading the client, giving it the public key,
    //and copying the pushSubscription object it returns after subscribing successfully...

    //This should ideally come from a DB? e.g. https://developers.google.com/web/fundamentals/push-notifications/subscribing-a-user
    // const clientPushSubscription = {
    //     endpoint: ''
    //     expirationTime: null,
    //     keys: {
    //       p256dh: '',
    //       auth: ''
    //     }
    // }


    const payload = JSON.stringify({
        body: 'from server body',
        data: { primaryKey: 'from server custom data' }
    });

    subscriptions.forEach((subscription) => {
        //sendNotification() automatically encrypts the payload
        webpush.sendNotification(subscription, payload, options).then(() => {
            res.status(200).send({ success: true });
        }).catch((err) => {
            if (err.statusCode) {
                res.status(err.statusCode).send(err.body);
            } else {
                res.status(400).send(err.message);
            }
        });
    });
});


var server = http.createServer(options, app);
server.listen(3005, () => console.log('Push service listening on 3005...'));



//Process

// - Generate vapid keys by hitting route, and enter in here, and application main.js
// - Initialise service worker on browser, and generate a pushSubscription object and copy into here into sendNotification method
// - Call /push on here to send a push notification to the browser.
    //Each browser will generate its own subscription however, so multiple subscriptions may need to be...
    //...tied to the same user in the database

    //Links
    //https://developers.google.com/web/fundamentals/push-notifications/web-push-protocol
    //https://developers.google.com/web/fundamentals/push-notifications/subscribing-a-user

// Browser compatibility? https://github.com/web-push-libs/web-push


//Portal
//- Create service to have push notifications, and have it generate VAPID keys and store them in ENV
//
//- Have an area in settings to turn on/off push notifications
    //- When turning them ON, it passes the registration object to be stored against the DID and saves in DB (use the endpoint as a unique identifier in database?)
    //- When turning them OFF, it removes from the DB the registration object against the DID
    //There may be multiple registration obejct against a single DID to represent each browser?
//

//Then in the Push service client (backend), when an event happens:
    //- Call web-push sendNotification() with the VAPID keys, and each browsers registration info from the DB...
    //...(so same notification will be sent to multiple browsers)